# 集成预测器使用指南

## 📋 概述

集成预测器是一个强大的多模型投票系统，通过组合多个机器学习模型的预测结果，提供更稳定和准确的抑郁风险预测。

## ✨ 主要特性

### 🔥 核心功能
- **多模型集成**: 支持随机森林、SVM、逻辑回归、梯度提升等多种模型
- **软投票机制**: 基于概率向量的加权平均，更稳定可靠
- **硬投票机制**: 基于预测结果的多数投票，备选方案
- **动态类别支持**: 自动检测类别数量，支持多分类问题
- **模型权重**: 基于训练历史性能的智能权重分配

### 🛡️ 健壮性特性
- **异常处理**: 完善的错误处理和回退机制
- **输入验证**: 严格的输入验证和特征维度检查
- **模型验证**: 概率向量维度和预测结果验证
- **日志记录**: 详细的日志记录和性能监控

### 📊 监控与分析
- **预测时间**: 记录每次预测的执行时间
- **预测分布**: 记录预测分布用于drift检测
- **模型一致性**: 计算模型间的一致性水平
- **详细概率**: 提供每个类别的详细概率分布

## 🚀 快速开始

### 1. 环境准备

确保已经训练并保存了模型：

```bash
# 1. 检查环境
python check_environment.py

# 2. 训练模型
python train_models.py
```

### 2. 基本使用

```bash
# 默认使用软投票，先测试再交互
python ensemble_predictor.py

# 仅运行测试
python ensemble_predictor.py --test-only

# 仅运行交互模式
python ensemble_predictor.py --interactive-only

# 使用硬投票
python ensemble_predictor.py --use-hard-voting

# 指定模型目录
python ensemble_predictor.py --models-dir custom_models
```

### 3. 编程接口

```python
from ensemble_predictor import EnsemblePredictor

# 创建预测器
predictor = EnsemblePredictor(
    models_dir="models",
    use_soft_voting=True  # 推荐使用软投票
)

# 进行预测
result = predictor.predict("I feel so sad today")

if result:
    print(f"预测结果: {result['ensemble_prediction']}")
    print(f"置信度: {result['ensemble_confidence']:.1%}")
    print(f"投票方法: {result['voting_method']}")
    print(f"模型一致性: {result['agreement_level']:.1%}")
    print(f"预测时间: {result['prediction_time']:.3f}秒")
```

## 📈 投票机制详解

### 软投票（推荐）

软投票通过平均所有模型的概率向量来做出最终预测：

```python
# 示例：3个模型的概率向量
model1_prob = [0.3, 0.7]  # 70%概率预测高风险
model2_prob = [0.6, 0.4]  # 40%概率预测高风险  
model3_prob = [0.2, 0.8]  # 80%概率预测高风险

# 加权平均（基于模型性能）
avg_prob = [0.37, 0.63]  # 平均后63%概率预测高风险
final_prediction = 1  # 预测高风险
```

**优点**:
- 利用完整的概率信息
- 更稳定，不容易受单个模型影响
- 能处理模型间的不确定性

### 硬投票

硬投票基于各模型的预测结果进行多数投票：

```python
# 示例：3个模型的预测
model1_pred = 1  # 预测高风险
model2_pred = 0  # 预测低风险
model3_pred = 1  # 预测高风险

# 多数投票
votes = [1, 0, 1]
majority = 1  # 2/3模型预测高风险
final_prediction = 1  # 最终预测高风险
```

**优点**:
- 简单直观
- 计算速度快
- 适合模型性能相近的情况

### 平局处理

当模型投票出现平局时：

```python
# 平局情况
votes = [0, 1]  # 一个预测低风险，一个预测高风险
agreement = 0.5

# 平局策略：优先选择高风险（类别1）
final_prediction = 1  # 保守策略，优先关注风险
```

## 🔧 高级配置

### 模型权重

模型权重基于训练历史自动计算：

```python
# 权重计算逻辑
if 'val_accuracy' in history:
    weight = history['val_accuracy']  # 优先使用验证准确率
elif 'train_accuracy' in history:
    weight = history['train_accuracy']  # 备选训练准确率
else:
    weight = 1.0  # 默认等权重
```

### 特征验证

系统会验证特征维度的一致性：

```python
# 特征维度检查
expected_features = len(processor.feature_names)
actual_features = X.shape[1]

if actual_features != expected_features:
    raise ValueError(f"特征维度不匹配: {expected_features} != {actual_features}")
```

### 概率向量验证

验证每个模型的概率向量维度：

```python
# 概率向量验证
for name, prob in probabilities.items():
    if len(prob) != n_classes:
        logger.warning(f"模型 {name} 概率向量维度不匹配")
        continue  # 跳过该模型
```

## 📊 输出结果详解

### 预测结果结构

```python
result = {
    'text': '输入文本',
    'individual_predictions': {
        'random_forest': 1,
        'svm': 0,
        'logistic_regression': 1
    },
    'individual_probabilities': {
        'random_forest': [0.3, 0.7],
        'svm': [0.6, 0.4],
        'logistic_regression': [0.2, 0.8]
    },
    'ensemble_prediction': 1,  # 最终预测
    'ensemble_confidence': 0.63,  # 置信度
    'voting_method': 'soft_voting',  # 投票方法
    'agreement_level': 0.67,  # 模型一致性
    'prediction_time': 0.123,  # 预测时间（秒）
    'n_classes': 2,  # 类别数量
    'class_names': ['低风险', '高风险'],  # 类别名称
    'avg_probabilities': [0.37, 0.63]  # 平均概率分布（软投票）
}
```

### 结果解释

- **ensemble_prediction**: 最终预测的类别索引
- **ensemble_confidence**: 预测的置信度（0-1）
- **voting_method**: 使用的投票方法
- **agreement_level**: 模型间的一致性（0-1）
- **prediction_time**: 预测耗时
- **avg_probabilities**: 各类别的平均概率（软投票）

## 🧪 测试与验证

### 运行单元测试

```bash
# 运行所有测试
python test_ensemble_predictor.py

# 运行特定测试
python -m unittest test_ensemble_predictor.TestEnsemblePredictor.test_voting_mechanism_soft
```

### 测试用例覆盖

- ✅ 初始化测试
- ✅ 投票机制测试
- ✅ 预测功能测试
- ✅ 异常处理测试
- ✅ 多类别支持测试
- ✅ 概率向量验证测试

## 🔍 故障排除

### 常见问题

#### 1. 模型文件不存在

```
FileNotFoundError: 模型目录不存在: models
```

**解决方案**:
```bash
# 先训练模型
python train_models.py
```

#### 2. 特征维度不匹配

```
ValueError: 特征维度不匹配: 期望 50, 实际 45
```

**解决方案**:
- 确保使用相同的数据处理器
- 重新训练模型和数据处理器

#### 3. 概率向量维度错误

```
Warning: 模型 svm 概率向量维度不匹配: 3 != 2
```

**解决方案**:
- 检查模型训练时的类别数量
- 重新训练模型

#### 4. 预测失败

```
Error: 所有模型预测都失败了
```

**解决方案**:
- 检查输入文本是否包含有效内容
- 验证模型文件完整性
- 查看详细错误日志

### 调试技巧

#### 1. 启用详细日志

```python
import logging
logging.basicConfig(level=logging.DEBUG)
```

#### 2. 检查模型状态

```python
predictor = EnsemblePredictor()
print(f"加载的模型: {list(predictor.models.keys())}")
print(f"模型权重: {predictor.model_weights}")
print(f"类别数量: {predictor.n_classes}")
```

#### 3. 验证特征提取

```python
# 检查特征提取
data = pd.DataFrame({'text': ['test text']})
processed = predictor.processor.process_social_media_data(data)
print(f"提取的特征: {predictor.processor.feature_names}")
```

## 📈 性能优化

### 1. 模型加载优化

```python
# 按需加载模型（适用于模型较多的情况）
predictor = EnsemblePredictor(lazy_loading=True)
```

### 2. 批量预测

```python
# 批量预测以提高效率
texts = ["text1", "text2", "text3"]
results = [predictor.predict(text) for text in texts]
```

### 3. 缓存机制

```python
# 启用预测结果缓存
predictor.enable_cache(max_size=1000)
```

## 🔮 未来扩展

### 计划功能

- [ ] 在线学习：支持模型增量更新
- [ ] 自动调优：自动选择最佳投票策略
- [ ] 模型解释：提供预测结果的解释
- [ ] 分布式预测：支持多进程预测
- [ ] 模型监控：实时监控模型性能

### 自定义扩展

```python
# 自定义投票策略
class CustomVotingStrategy:
    def __init__(self, threshold=0.6):
        self.threshold = threshold
    
    def vote(self, predictions, probabilities):
        # 自定义投票逻辑
        pass

# 使用自定义策略
predictor = EnsemblePredictor(voting_strategy=CustomVotingStrategy())
```

## 📞 技术支持

### 获取帮助

1. **查看日志**: 检查详细的错误日志
2. **运行测试**: 使用单元测试验证功能
3. **环境检查**: 运行 `check_environment.py`
4. **文档参考**: 查看相关文档和示例

### 报告问题

当遇到问题时，请提供以下信息：

- 错误信息和堆栈跟踪
- 输入文本示例
- 模型文件版本
- 系统环境信息
- 复现步骤

---

**注意**: 本系统仅用于研究和演示目的，不构成医疗建议。在实际应用中，请咨询专业医疗人员。
